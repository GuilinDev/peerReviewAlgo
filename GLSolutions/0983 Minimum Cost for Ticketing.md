## Solution 1
> DP，思路如下
> 提前1年计划，一年365天
* 今天不需要出门，不用买票
* 今天如果要出门，需要买几天？
  * 看往后几天（比如例子中通票最多30天）要不要出门
  * 30天内都没有要出行的，那只买今天就好
  * 30天有要出门的（不同决策）
    * 这次 和 后面几次**分开**买更省
    * 这次 和 后面几次**一起**买更省

将上面的思路细化一下：

0. 因为“今天应该买多少，得看后几天怎么安排”，即“前面依赖后面”，所以后面是DP的初始化，从后向前来买，例如题目例子 days = [1,4,6,7,8,20]，costs = [2,7,15]
1. 第 21 天及以后的日子都不需要出门，不用买票
2. 第 20 天需要出门，需要买几天？
3. 不考虑 20 之前要不要出门，否则与思路相违背
4. 第 20 之后没有出门日，故买「一天」的 costs[0] 最省钱
5. 第 9 - 19 不需要出门，则不用买
6. 第 8 需要出门，需要买几天？
  * 往后（只需看往后30天）有出门的需求
    * 决策1：买1天期，后面的不包，cost等于 $2 + $2 = $4
    * 决策2：买七天期，包到第 8 + 7 - 1 天，第 8 + 7 天往后的不包，cost等于 $2 + $2 = $4
    * 决策3：买三十天期，包到第 8 + 30 - 1 天，第 8 + 30 天往后的不包，cost等于 $15，第 20 可不用花钱

假设题目只有 [8, 20] 两天需要出行，则
```java
int result8 = min(cost[0] + cost[0], cost[1] + cost[0], cost[2] + 0);
// 第 8 天  = min(决策1，             决策2,             决策3);
```

7. 抽象，定义状态，确定从后向前的递推公式
将上述结果换个说法：「result 为第 8 天开始，所需最小费用 累计」
抽象，定义状态： 「dp[i] 为第 i 天开始，所需最小费用 累计」
则
```java
dp[i] = min(决策1, 决策2, 决策3);
      = min(cost[0] + 1天后不包, cost[1] + 7天后不包, cost[2] + 30天不包);
      = min(cost[0] + dp[i + 1], cost[1] + dp[i + 7], cost[2] + dp[i + 30]);
```
代码，时间复杂度O(n) - O(maxDay - minDay)，空间复杂度O(n) - O(maxDay)
```java
class Solution {
    public int mincostTickets(int[] days, int[] costs) {
        int len = days.length;
        int maxDay = days[len - 1];
        int minDay = days[0];

        int[] dp = new int[maxDay + 31]; // +31是因为有可能在最大的天数上增加一个月，以免12月出行还要判断365是不是足够，但要是直接写365 + 31也行
        for (int d = maxDay, i = len - 1; d >= minDay; d--) { // 只需看 maxDay -> minDay，此区间外都不需要出门，不会增加费用
            // i 表示 days 出行日的索引
            // 也可提前将所有 days 放入 Set，再通过 set.contains() 判断
            if (d == days[i]) {
                dp[d] = Math.min(dp[d + 1] + costs[0], Math.min(dp[d + 7] + costs[1], dp[d + 30] + costs[2]));
                i--; // 从后向前，计算后还需要递减到前面的出行日索引
            } else {
                dp[d] = dp[d + 1]; //不是出门日
            }
        }
        return dp[minDay];
    }
}
```

