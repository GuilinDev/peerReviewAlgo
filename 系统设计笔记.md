# 1. 数据持久化层场景
## 1.1 冷热分离 Hot Warm (Hot Cold) Architecture
场景：供应链有个订单功能，里面的主表有几千万的数据量，加上关联表，数据量达到上亿，这么庞大的数据量，让平台的订单查询非常缓慢（查询一次需要二三十秒），多点几次还会出现宕机。比如业务员多次查询时，数据库的CPU会立即狂飙，服务器的线程数也降不下来。

Initiative的解决方案：优化表结构，优化业务代码，添加索引，优化SQL语句等，但查询速度还是很慢。

性价比高的解决方案：简单方便地解决了这个问题。在处理数据时，将数据库分成了冷库和热库 2 个库，不常用数据放冷库，常用数据放热库。通过这样的方法处理后，因为业务员查询的基本是近期常用的数据，常用的数据量大大减少了，就再也不会出现宕机的情况了，也大大提升了数据库响应速度。

> 冷热分离就是在处理数据时将数据库分成冷库和热库 2 个库，冷库指存放那些走到了终态的数据的数据库，热库指存放还需要修改的数据的数据库。

假设你务需求出现了如下情况，就可以考虑使用冷热分离的解决方案：
* 数据走到终态后，只有读没有写的需求，比如订单完结状态；
* 用户能接受新旧数据分开查询，比如有些电商网站默认只让查询 3 个月内的订单，如果你要查询 3 个月前的订单，还需要访问另外的单独页面。

在实际操作过程中，冷热分离整体实现思路如下：

（一）如何判断一个数据到底是冷数据还是热数据？ - 主要采用主表里的 1 个或多个字段组合的方式作为区分标识（时间维度/状态维度/组合维度）。

* 如果一个数据被标识为冷数据，业务代码不会再对它进行写操作；
* 不会同时存在读冷/热数据的需求。

（二）如何触发冷热数据分离？
* 直接修改业务代码，每次修改数据时触发冷热分离（比如每次更新了订单的状态，就去触发这个逻辑） - 建议在业务代码比较简单，并且不按照时间区分冷热数据时使用。
* 如果不想修改原来的业务代码，可通过监听数据库变更日志 binlog 的方式（订阅消费）来触发 - 建议在业务代码比较复杂，不敢随意变更，并且不按照时间维度区分冷热数据时使用。
* 通过定时扫描数据库的方式来触发 - 建议在按照时间维度区分冷热数据时使用

（三）如何实现冷热数据分离？
* 判断数据是冷是热；
* 将要分离的数据插入冷数据库中；
* 再从热数据库中删除分离的数据。

以下 3 点我们都得考虑在：
* 一致性：同时修改多个数据库，如何保证数据的一致性？ - 保证每一步都可以重试且操作都有幂等性就行（热数据库中加标识冷数据库中保持幂等）
* 数据量：假设数据量大，一次性处理不完，该怎么办？是否需要使用批量处理？ - 只有定时扫描需要考虑数据量问题（直接修改业务代码和监听数据库binlog都是处理瞬时变更的数据），搬数据的地方我们加个批量逻辑就可以了，例如一次搬50条。
* 并发性：假设数据量大到要分到多个地方并行处理，该怎么办？ - 单线程并发处理都来不及，这时候可以考虑多线程 （大部分情况下多线程较快，但也有这种情况：当单线程 batch size 到一定数值时效率特别高，比多线程任何 batch size 都快。所以，到时多留意下，如果遇到多线程速度不快，就考虑控制单线程。）

（四）如何使用冷热数据？
* 在功能设计的查询界面上，一般都会有一个选项供我们选择需要查询冷数据还是热数据（例如查询三个月的订单系统还是更早的所有订单），如果界面上没有提供，我们可以直接在业务代码里区分。（说明：在判断是冷数据还是热数据时，必须确保用户不允许有同时读冷热数据的需求。）

历史数据的迁移 
* 只要跟持久化层有关的架构方案，我们都需要考虑历史数据的迁移问题，即如何让旧架构的历史数据适用于新的架构？ - 给需要迁移的所有历史数据加标识：ColdFlag=WaittingForMove，然后步骤跟上面一样。

Hot Warm Architecture的不足
* 用户查询冷数据速度依旧很慢，如果查询冷数据的用户比例很低，比如只有 1%，那么这个方案就没问题
* 业务无法再修改冷数据，因为冷数据多到一定程度时，系统承受不住。（这点可以通过冷库再分库来解决）

# 2. 缓存层场景


# 3. 微服务场景常见组件


# 4. 微服务的坑


# 5. 微服务进阶


# 6. DEVOPS场景
